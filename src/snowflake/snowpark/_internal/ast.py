#!/usr/bin/env python3
#
# Copyright (c) 2012-2024 Snowflake Computing Inc. All rights reserved.
#

import base64
import itertools
import json
import sys
import uuid
from dataclasses import dataclass
from typing import Any, Callable, Sequence, Tuple

from google.protobuf.json_format import ParseDict

import snowflake.snowpark._internal.proto.ast_pb2 as proto
from snowflake.connector.arrow_context import ArrowConverterContext
from snowflake.connector.cursor import ResultMetadataV2
from snowflake.connector.result_batch import ArrowResultBatch
from snowflake.snowpark._internal.error_message import SnowparkClientExceptionMessages
from snowflake.snowpark.exceptions import SnowparkSQLException
from snowflake.snowpark.version import VERSION

# The current AST version number (generated by the DSL).
CLIENT_AST_VERSION = proto.__Version__.MAX_VERSION


# TODO: currently unused.
def expr_to_dataframe_expr(expr):
    dfe = proto.SpDataframeExpr()
    variant = expr.WhichOneof("variant")
    getattr(dfe, variant).CopyFrom(getattr(expr, variant))
    return dfe


@dataclass
class TrackedCallable:
    var_id: int
    func: Callable


class AstBatch:
    # Function used to generate request IDs. This is overridden in some tests.
    generate_request_id = uuid.uuid4

    def __init__(self, session) -> None:
        self._session = session
        self.reset_id_gen()
        self._init_batch()

        # Track callables in this dict (memory id -> TrackedCallable).
        self._callables = {}

    def reset_id_gen(self):
        self._id_gen = itertools.count(start=1)

    def assign(self, symbol=None):
        stmt = self._request.body.add()
        # TODO: extended BindingId spec from the branch snowpark-ir.
        stmt.assign.uid = next(self._id_gen)
        stmt.assign.var_id.bitfield1 = stmt.assign.uid
        stmt.assign.symbol.value = symbol if isinstance(symbol, str) else ""
        return stmt.assign

    def eval(self, target):
        stmt = self._request.body.add()
        stmt.eval.uid = next(self._id_gen)
        stmt.eval.var_id.CopyFrom(target.var_id)

    def flush(self) -> Tuple[str, str]:
        """Ties off a batch and starts a new one. Returns the tied-off batch."""
        batch = str(base64.b64encode(self._request.SerializeToString()), "utf-8")
        self._init_batch()
        return (str(self._request_id), batch)

    def _init_batch(self):
        self._request_id = AstBatch.generate_request_id()  # Generate a new unique ID.
        self._request = proto.Request()

        (major, minor, patch) = VERSION
        self._request.client_version.major = major
        self._request.client_version.minor = minor
        self._request.client_version.patch = patch

        (major, minor, micro, releaselevel, serial) = sys.version_info
        self._request.client_language.python_language.version.major = major
        self._request.client_language.python_language.version.minor = minor
        self._request.client_language.python_language.version.patch = micro
        self._request.client_language.python_language.version.label = releaselevel

        self._request.client_ast_version = CLIENT_AST_VERSION

    def register_callable(self, func: Callable) -> int:
        """Tracks client-side an actual callable and returns an ID."""
        k = id(func)

        if k in self._callables.keys():
            return self._callables[k].var_id

        next_id = len(self._callables)
        self._callables[k] = TrackedCallable(var_id=next_id, func=func)
        return next_id
