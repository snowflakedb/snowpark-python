#
# Copyright (c) 2012-2024 Snowflake Computing Inc. All rights reserved.
#
import logging
import threading
import weakref
from collections import defaultdict
from queue import Queue
from typing import TYPE_CHECKING, Dict, Optional

from snowflake.snowpark._internal.analyzer.snowflake_plan_node import SnowflakeTable

if TYPE_CHECKING:
    from snowflake.snowpark.session import Session  # pragma: no cover


class TempTableAutoCleaner:
    """
    Clean up temporary tables created automatically by Snowpark at the session level.

    This function identifies and removes any temporary tables that have been
    generated by Snowpark during the current session. Temporary tables are
    typically used for intermediate computations (e.g., df.cache_result) and
    are not needed when they are not referenced anymore. Removing these tables
    helps maintain a clean working environment and reduce storage cost for a long-running
    session.
    """

    def __init__(self, session: "Session") -> None:
        self.session = session
        # this dict maintains key-value pair from Snowpark-generated temp table fully-qualified name
        # to its reference count for later temp table management
        # this dict will still be maintained even if the cleaner is stopped (`stop()` is called)
        self.ref_count_map: Dict[str, int] = defaultdict(int)
        self.queue: Queue = Queue()
        self.cleanup_thread: Optional[threading.Thread] = None

    def add(self, table: SnowflakeTable) -> None:
        self._inc_ref_count(table.name)
        # the finalizer will be triggered when it gets garbage collected
        # and this table will be dropped finally
        _ = weakref.finalize(table, self._dec_ref_count, table.name)

    def _inc_ref_count(self, name: str) -> None:
        self.ref_count_map[name] += 1

    def _dec_ref_count(self, name: str) -> None:
        self.ref_count_map[name] -= 1
        if self.ref_count_map[name] == 0:
            self.ref_count_map.pop(name)
            # clean up
            if self.is_alive():
                self.queue.put(name)
        elif self.ref_count_map[name] < 0:
            logging.debug(
                f"Unexpected reference count {self.ref_count_map[name]} for table {name}"
            )

    def process_cleanup(self) -> None:
        while True:
            table_name = self.queue.get()
            if table_name is None:
                # exit the thread loop
                break
            self.drop_table(table_name)

    def drop_table(self, name: str) -> None:
        common_log_text = f"temp table {name} in session {self.session.session_id}"
        logging.debug(f"Cleanup Thread: Ready to drop {common_log_text}")
        try:
            # TODO SNOW-1556553: Remove this workaround once multi-threading of Snowpark session is supported
            with self.session._conn._conn.cursor() as cursor:
                cursor.execute(f"drop table if exists {name}")
            logging.debug(f"Cleanup Thread: Successfully dropped {common_log_text}")
        except Exception:
            logging.warning(
                f"Cleanup Thread: Failed to drop {common_log_text}"
            )  # pragma: no cover

    def is_alive(self) -> bool:
        return self.cleanup_thread is not None and self.cleanup_thread.is_alive()

    def start(self) -> None:
        if not self.is_alive():
            self.cleanup_thread = threading.Thread(target=self.process_cleanup)
            self.cleanup_thread.start()

    def stop(self) -> None:
        if self.is_alive():
            # None will break the loop in cleanup thread and force it exit
            # then we can call thread.join() to stop this thread
            self.queue.put(None)
            self.cleanup_thread.join()
