#
# Copyright (c) 2012-2024 Snowflake Computing Inc. All rights reserved.
#
import logging
import weakref
from collections import defaultdict
from queue import Empty, Queue
from threading import Event, Thread
from typing import TYPE_CHECKING, Dict, Optional

from snowflake.snowpark._internal.analyzer.snowflake_plan_node import SnowflakeTable

if TYPE_CHECKING:
    from snowflake.snowpark.session import Session  # pragma: no cover


class TempTableAutoCleaner:
    """
    Clean up temporary tables created automatically by Snowpark at the session level.

    This function identifies and removes any temporary tables that have been
    generated by Snowpark during the current session. Temporary tables are
    typically used for intermediate computations (e.g., df.cache_result) and
    are not needed when they are not referenced anymore. Removing these tables
    helps maintain a clean working environment and reduce storage cost for a long-running
    session.
    """

    def __init__(self, session: "Session") -> None:
        self.session = session
        # this dict maintains key-value pair from Snowpark-generated temp table fully-qualified name
        # to its reference count for later temp table management
        # this dict will still be maintained even if the cleaner is stopped (`stop()` is called)
        self.ref_count_map: Dict[str, int] = defaultdict(int)
        self.queue: Queue = Queue()
        self.cleanup_thread: Optional[Thread] = None
        self.stop_event = Event()

    def add(self, table: SnowflakeTable) -> None:
        self.ref_count_map[table.name] += 1
        # the finalizer will be triggered when it gets garbage collected
        # and this table will be dropped finally
        _ = weakref.finalize(table, self._delete_ref_count, table.name)

    def _delete_ref_count(self, name: str) -> None:
        self.ref_count_map[name] -= 1
        if self.ref_count_map[name] == 0:
            self.ref_count_map.pop(name)
            # clean up
            self.queue.put(name)
        elif self.ref_count_map[name] < 0:
            logging.debug(
                f"Unexpected reference count {self.ref_count_map[name]} for table {name}"
            )

    def process_cleanup(self) -> None:
        while not self.stop_event.is_set():
            try:
                # it's non-blocking after timeout and become interruptable with stop_event
                # it will raise an `Empty` exception if queue is empty after timeout,
                # then we catch this exception and avoid breaking loop
                table_name = self.queue.get(timeout=1)
                self.drop_table(table_name)
            except Empty:
                continue

    def drop_table(self, name: str) -> None:
        common_log_text = f"temp table {name} in session {self.session.session_id}"
        logging.debug(f"Cleanup Thread: Ready to drop {common_log_text}")
        try:
            # TODO SNOW-1556553: Remove this workaround once multi-threading of Snowpark session is supported
            with self.session._conn._conn.cursor() as cursor:
                cursor.execute(f"drop table if exists {name}")
            logging.debug(f"Cleanup Thread: Successfully dropped {common_log_text}")
        except Exception:
            logging.warning(
                f"Cleanup Thread: Failed to drop {common_log_text}"
            )  # pragma: no cover

    def is_alive(self) -> bool:
        return self.cleanup_thread is not None and self.cleanup_thread.is_alive()

    def start(self) -> None:
        if not self.is_alive():
            self.stop_event.clear()
            self.cleanup_thread = Thread(target=self.process_cleanup)
            self.cleanup_thread.start()

    def stop(self, graceful: bool = False) -> None:
        """
        If graceful is True, the cleaner will finish dropping remaining tables in the queue.
        If it is False, the cleaner will stop immediately.
        """
        if self.is_alive():
            self.stop_event.set()
            self.cleanup_thread.join()
            if graceful:
                while not self.queue.empty():
                    table_name = self.queue.get()
                    self.drop_table(table_name)
