#
# Copyright (c) 2012-2022 Snowflake Computing Inc. All rights reserved.
#

import ast
import builtins
import dis
import inspect
import pickle
import re
import sys
import textwrap
from collections import defaultdict
from logging import getLogger
from types import BuiltinFunctionType, CodeType, FunctionType, ModuleType
from typing import Any, Iterable, Set, Union

import opcode

logger = getLogger(__name__)

STORE_GLOBAL = opcode.opmap["STORE_GLOBAL"]
DELETE_GLOBAL = opcode.opmap["DELETE_GLOBAL"]
LOAD_GLOBAL = opcode.opmap["LOAD_GLOBAL"]
GLOBAL_OPS = (STORE_GLOBAL, DELETE_GLOBAL, LOAD_GLOBAL)

CODE_AS_COMMENT_HINT = (
    "The following comment contains the UDF source code"
    " generated by snowpark-python for explanatory purposes.\n"
)
CODE_HEADER = """\
from __future__ import annotations
import pickle
"""


def get_func_references(func: FunctionType, ref_objects: dict) -> None:
    # 1. resolve function global references
    code_object = func.__code__
    globals_ref = extract_func_global_refs(
        func.__code__
    )  # get the names of the objects which func references
    globals = {
        k: func.__globals__[k]
        for k in globals_ref
        if k in func.__globals__  # retrieve the objects by names
        and k not in ref_objects
    }

    ref_objects.update(globals)

    # 2. resolve function closure references
    if func.__closure__ is not None:
        closures = {
            k: v
            for k, v in zip(
                code_object.co_freevars,
                list(map(lambda x: x.cell_contents, func.__closure__)),
            )
        }
        for k, v in closures.items():
            ref_objects[k] = v
            # if the closure item is a function and is not itself (recursive) and has not been visited
            if isinstance(v, FunctionType) and k not in ref_objects and v != func:
                get_func_references(v, ref_objects)


def get_class_references(
    cls: type, func_module_name: str, ref_objects: dict, classes_to_generate: list
) -> None:
    """
    To get the referenced objects of a dynamically defined class.
    A class could have methods, classes referencing objects.

    """
    # order matters to classes_to_generate, when constructing source code, referenced classes need to be defined first.
    classes_to_generate.insert(0, cls)
    # get base classes first
    inferred_clses = [v for v in reversed(cls.__bases__) if v.__qualname__ != "object"]

    # __dict__ contains function, classmethod, classes attributes within a given class which
    # needs to be further analyzed
    clsdict = dict(cls.__dict__)
    for v in clsdict.values():
        if isinstance(v, type) and v.__module__ == func_module_name:
            # v is a class defined in the same module as UDF func's, need to dynamically parse the class
            inferred_clses.append(v)
        elif inspect.isfunction(v) or isinstance(v, classmethod):
            # v is a function/classmethod, get the references objects of the Function object
            get_func_references(
                v if not isinstance(v, classmethod) else v.__func__, ref_objects
            )

    # recursively handling classes that should be parsed dynamically
    for more_cls in inferred_clses:
        get_class_references(
            more_cls, func_module_name, ref_objects, classes_to_generate
        )


def extract_func_global_refs(code: CodeType) -> dict:
    # inspired by cloudpickle to recursively extract all the global references used by the target func's code object
    co_names = code.co_names
    out_names = {}
    for instr in dis.get_instructions(code):
        op = instr.opcode
        if op in GLOBAL_OPS:
            out_names[co_names[instr.arg]] = None

    if code.co_consts:
        for const in code.co_consts:
            if isinstance(const, CodeType):
                out_names.update(extract_func_global_refs(const))

    return out_names


def remove_function_udf_annotation(
    udf_source_code: str, code_as_comment: bool = True
) -> str:
    if code_as_comment:
        return udf_source_code
    # remove the udf/pandas_udf annotation to avoid re-registration
    res = re.search(r"@(udf|pandas_udf)\(", udf_source_code)
    if res is None:
        return udf_source_code
    udf_anno_begin = res.start()
    udf_anno_end = res.end()
    cnt = 1

    # find the pairing ')' of the leading 'udf('
    while cnt != 0:
        if udf_source_code[udf_anno_end] == "(":
            cnt += 1
        elif udf_source_code[udf_anno_end] == ")":
            cnt -= 1
        udf_anno_end += 1

    return udf_source_code[:udf_anno_begin] + udf_source_code[udf_anno_end:]


def check_func_type(func: Any) -> None:
    if (
        isinstance(func, classmethod)
        or inspect.ismethod(func)
        or not (isinstance(func, (FunctionType, BuiltinFunctionType)))
    ):
        logger.debug(f"Code generation for {type(func)} is not supported yet.")
        raise TypeError(f"Code generation for {type(func)} is not supported yet.")


def generate_source_code(
    func: Union[FunctionType, BuiltinFunctionType], code_as_comment: bool = True
) -> str:
    """
    Dynamically generate source code of the given Python functions including:
      - The function itself
      - The functions/classes that are defined and referenced by the target function in the same module
      - The modules/class/method that have to be imported as used by the target function
      - The global or closure variables used by the target function

    The current implementation locks the support for the following scenarios:
     - Decorated functions: https://snowflakecomputing.atlassian.net/browse/SNOW-644983
     - Method and classmethod: https://snowflakecomputing.atlassian.net/browse/SNOW-644984

    param func: The target function that has to been generated
    param code_as_comment: All lines of the generated source code will be prefixed with '#' in which case code
     are turned in comments. This is the default behavior.
    """

    try:
        check_func_type(func)
    except TypeError:
        if code_as_comment:
            # if it is an unsupported type, then no code generation and return emtpy string
            return ""
        raise

    # stored referenced object, key is the object name, value is the object
    ref_objects = {}
    # stored modules, each item should be a tuple of two strings, first is the true module name, second is the used name
    # such as alias or just the name
    to_import = set()
    # imports class/funcs/vars form other modules, each key is the module name
    # each item is a set of tuples of two strings as the to_import, first module name, second alias
    to_import_from_module = defaultdict(set)
    # classes that should be generated source code
    classes_to_generate = []

    header_text = CODE_AS_COMMENT_HINT if code_as_comment else CODE_HEADER
    global_vars_text = ""
    func_text = ""
    classes_text = ""

    func_module_name = func.__module__

    # 1. Resolve objects referenced by functions including classes, methods, modules, global variables
    if isinstance(func, FunctionType):
        get_func_references(func, ref_objects)
        to_import = to_import.union(
            extract_submodule_imports(
                func, [v for v in ref_objects.values() if isinstance(v, ModuleType)]
            )
        )
        for v in [
            v
            for v in ref_objects.values()
            if inspect.isclass(v) and v.__module__ == func_module_name
        ]:
            get_class_references(v, func_module_name, ref_objects, classes_to_generate)
    elif isinstance(func, BuiltinFunctionType):
        if func_module_name != builtins.__name__:
            to_import.add((func_module_name, func_module_name))

    # 2. Dealing with the referenced objects by types
    for name, obj in ref_objects.items():
        if obj == func:
            continue
        if inspect.ismodule(obj):
            # a) imported modules
            to_import.add((obj.__name__, name))  # name could be an alias
        elif (
            inspect.isclass(obj) or inspect.isfunction(obj)
        ) and obj.__module__ != func_module_name:
            # b) classes or functions imported from other modules
            to_import_from_module[obj.__module__].add(
                (obj.__name__, name)
            )  # name could be an alias
        else:
            # function/class/variables defined in the same module
            if inspect.isfunction(obj):
                func_text += textwrap.dedent(inspect.getsource(obj))
            elif inspect.isclass(obj):
                # dynamic class parsing will be handled separately
                pass
            else:
                # c) global variables used by UDF
                if code_as_comment:
                    global_vars_text += f"{name}  # variable of type {type(obj)}\n"
                    continue  # skip the serialization part if we just need code as comment
                # v does not have source code, then it's a global variable of which the value has been evaluated
                try:
                    global_vars_text += f"""
{name} = pickle.loads(bytes.fromhex('{pickle.dumps(obj).hex()}'))  \
# {name} is of type {type(obj)} and serialized by snowpark-python
"""
                except Exception as exc:
                    logger.debug(
                        "Unable to generate source code for object %s of type %s due to exception %r",
                        type(name),
                        type(obj),
                        exc,
                    )
                    raise

    # 3. deal with the classes defined in the same module as func's
    for cls in classes_to_generate:
        classes_text += textwrap.dedent(inspect.getsource(cls))

    # 4. deal with imports and alias
    imports = [
        f"import {name + ' as ' if name != alias else ''}{alias}"
        for name, alias in to_import
    ]
    for module, name_alias_pair in to_import_from_module.items():
        classes = ", ".join(
            f"{name + ' as ' if name != alias else ''}{alias}"
            for name, alias in name_alias_pair
        )
        imports.append(f"from {module} import {classes}")

    imports_str = "\n".join(imports) + ("\n" if imports else "")
    complete_source_code = f"{header_text}{imports_str}{global_vars_text}{classes_text}{func_text}".rstrip()

    # 5. handle func, remove the udf annotation
    if isinstance(func, FunctionType):
        func_source_code = remove_function_udf_annotation(
            textwrap.dedent(inspect.getsource(func))
        )
        if not is_lambda(func):
            complete_source_code = f"{complete_source_code}\n{func_source_code}"
        func_assignment = (
            get_lambda_code_text(func_source_code) if is_lambda(func) else func.__name__
        )
    else:
        # BuiltinFunctionType
        func_assignment = (
            func.__name__
            if func_module_name == builtins.__name__
            else f"{func_module_name}.{func.__name__}"
        )

    # 6. handle function assignment
    complete_source_code = f"""\
{complete_source_code}
{f"func = {func_assignment}"}\
""".strip()

    # 7. if code as comment is true, prefix each line with '#'
    complete_source_code = (
        complete_source_code
        if not code_as_comment
        else "\n".join(
            [
                f"#{f' {line}' if line else ''}"
                for line in complete_source_code.splitlines()
            ]
        )
    )

    return complete_source_code.strip()


def is_lambda(func: FunctionType) -> bool:
    return func.__name__ == "<lambda>"


def get_lambda_code_text(code_text: str) -> str:
    # add a wrapper to handle the case that the line of lambda source code does not include caller
    # such that ast could parse the expression tree:
    #     session.udf.register(
    #         lambda x, y: x + y, ...
    #     )
    try:
        source_ast = ast.parse(code_text)
    except SyntaxError as exc:
        if "cannot assign to lambda" in str(exc):
            # handle case like:
            # session.udf.register(
            #    lambda x, y: x + y, ...
            # )
            code_text = f"wrapper({code_text})"
        elif "unmatched ')'" in str(exc):
            # handle case like:
            # session.udf.register(
            #    lambda x, y: x + y, ...)
            code_text = f"wrapper({code_text}"
        source_ast = ast.parse(code_text)
    lambda_node = next(
        (node for node in ast.walk(source_ast) if isinstance(node, ast.Lambda)), None
    )
    if not lambda_node:
        raise TypeError("lambda function can not be extracted")

    lines = code_text.splitlines()
    # single line lambda
    if len(lines) == 1:
        return code_text[lambda_node.col_offset : lambda_node.end_col_offset]

    lambda_code_text = ""
    # lambda of multiple lines
    # handle case like:
    # session.udf.register(
    #    lambda x, y:\
    #    x + y, ...)
    for line_idx in range(lambda_node.lineno - 1, lambda_node.end_lineno):
        line = lines[line_idx]
        if line_idx == 0:
            lambda_code_text += f"{line[lambda_node.col_offset:]}\n"
        elif line_idx == lambda_node.end_lineno - 1:
            lambda_code_text += line[: lambda_node.end_col_offset]
        else:
            lambda_code_text += f"{line}\n"
    return lambda_code_text


def extract_submodule_imports(
    func: FunctionType, top_level_modules: Iterable[ModuleType]
) -> Set[tuple]:
    """
    Get submodule imports, the func code co_names only gives the top level module names, the submodule imports
    have to be inferred manually. Consider the following example:

    import a1.a2.a3.a4
    def func():
        a1.a2.a3.a4.foo()

    func.__code__.co_names only contains ("a1", "a2", "a3", "a4", "foo") which does not include the
    complete import path information.

    To reconstruct "a1.a2.a3.a4", the current strategy is to import each prefix import of the import chains.
    This is not a perfect solution as we could import modules not used, but it works.
    """
    imports = set()
    for module in top_level_modules:
        module_prefix = f"{module.__name__}."
        for name in [m for m in sys.modules if m.startswith(module_prefix)]:
            tokens = set(name[len(module_prefix) :].split("."))
            if not tokens - set(
                func.__code__.co_names
            ):  # only add imports that co_names contains
                imports.add((name, name))
    return imports
