#
# Copyright (c) 2012-2024 Snowflake Computing Inc. All rights reserved.
#

import logging
import threading
from collections import defaultdict
from queue import Queue
from typing import TYPE_CHECKING, Dict

if TYPE_CHECKING:
    from snowflake.snowpark.session import Session


class TempTableCleaner:
    """
    Clean up temporary tables created automatically by Snowpark at the session level.

    This function identifies and removes any temporary tables that have been
    generated by Snowpark during the current session. Temporary tables are
    typically used for intermediate computations (e.g., df.cache_result) and
    are not needed when they are not referenced anymore. Removing these tables
    helps maintain a clean working environment and reduce storage cost for a long-running
    session.
    """

    def __init__(self, session: "Session") -> None:
        self.session = session
        # this dict maintains key-value pair from Snowpark-generated temp table fully-qualified name
        # to its reference count for later temp table management
        # this dict will still be maintained even if the cleaner is stopped (`stop()` is called)
        self.ref_count_map: Dict[str, int] = defaultdict(int)
        self.queue = Queue()
        self.cleanup_thread = None

    def inc_ref_count(self, name: str) -> None:
        self.ref_count_map[name] += 1

    def dec_ref_count(self, name: str) -> None:
        self.ref_count_map[name] -= 1
        if self.ref_count_map[name] <= 0:
            self.ref_count_map.pop(name)
            # clean up
            if self.is_alive():
                self.queue.put(name)

    def process_cleanup(self) -> None:
        while True:
            table_name = self.queue.get()
            if table_name is None:
                # exit the thread loop
                break
            self.drop_table(table_name)

    def drop_table(self, name: str) -> None:
        common_log_text = f"temp table {name} in session {self.session.session_id}"
        try:
            self.session.sql(
                f"drop table {name}"
            )._internal_collect_with_tag_no_telemetry()
            logging.debug(f"Cleanup Thread: Successfully dropped {common_log_text}")
        except Exception:
            logging.debug(f"Cleanup Thread: Failed to drop {common_log_text}")

    def is_alive(self) -> bool:
        return self.cleanup_thread is not None and self.cleanup_thread.is_alive()

    def start(self) -> None:
        if not self.is_alive():
            self.cleanup_thread = threading.Thread(target=self.process_cleanup)
            self.cleanup_thread.start()

    def stop(self) -> None:
        if self.is_alive():
            self.queue.put(None)
            self.cleanup_thread.join()
