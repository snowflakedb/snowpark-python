#
# Copyright (c) 2012-2024 Snowflake Computing Inc. All rights reserved.
#

import math

import pytest

from snowflake.snowpark._internal.code_generation import (
    extract_submodule_imports,
    generate_source_code,
    get_class_references,
    get_func_references,
    get_lambda_code_text,
    remove_function_udf_annotation,
)

try:
    from dateutil.relativedelta import relativedelta

    is_dateutil_available = True
except ImportError:
    is_dateutil_available = False

try:
    import pandas  # noqa: F401

    is_pandas_available = True
except ImportError:
    is_pandas_available = False


def test_basic_udf():
    def add(x, y):
        return x + y

    assert (
        generate_source_code(add)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# def add(x, y):
#     return x + y
#
# func = add\
"""
    )
    lambda_func = lambda x, y: x * y  # noqa: E731
    assert (
        generate_source_code(lambda_func)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# func = lambda x, y: x * y\
"""
    )


def test_non_local_or_global_vars():
    var = 123

    def udf():
        return var + 1

    assert (
        generate_source_code(udf)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# var  # variable of type <class 'int'>
# def udf():
#     return var + 1
#
# func = udf\
"""
    )


def test_recursive_udf():
    def factorial(n):
        return 1 if n == 1 or n == 0 else n * factorial(n - 1)

    assert (
        generate_source_code(factorial)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# def factorial(n):
#     return 1 if n == 1 or n == 0 else n * factorial(n - 1)
#
# func = factorial\
"""
    )


def test_nested_udf():
    def outer_func():
        def inner_func():
            return "snow"

        return f"{inner_func()}-{inner_func()}"

    def square(x):
        return x**2

    def cube(x):
        return square(x) * x

    assert (
        generate_source_code(outer_func)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# def outer_func():
#     def inner_func():
#         return "snow"
#
#     return f"{inner_func()}-{inner_func()}"
#
# func = outer_func\
"""
    )

    assert (
        generate_source_code(cube)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# def square(x):
#     return x**2
# def cube(x):
#     return square(x) * x
#
# func = cube\
"""
    )


def test_python_built_in():
    def my_sqrt(x):
        return math.sqrt(x)

    assert (
        generate_source_code(my_sqrt)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import math
# def my_sqrt(x):
#     return math.sqrt(x)
#
# func = my_sqrt\
"""
    )

    assert (
        generate_source_code(abs)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# func = abs\
"""
    )

    assert (
        generate_source_code(math.sqrt)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import math
# func = math.sqrt\
"""
    )


def test_class_used_in_udf():
    import datetime

    class Foo:
        def bar(self):
            return 1

    class Parent(Foo):
        class Child:
            def bar(self):
                return 1

    def udf(a, b):
        return Foo().bar() + datetime.datetime.now().year

    def udf_nested_class(a, b):
        return Parent().Child().bar() + datetime.datetime.now().year

    assert (
        generate_source_code(udf)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import datetime
# class Foo:
#     def bar(self):
#         return 1
# def udf(a, b):
#     return Foo().bar() + datetime.datetime.now().year
#
# func = udf\
"""
    )

    assert (
        generate_source_code(udf_nested_class)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import datetime
# class Foo:
#     def bar(self):
#         return 1
# class Parent(Foo):
#     class Child:
#         def bar(self):
#             return 1
# def udf_nested_class(a, b):
#     return Parent().Child().bar() + datetime.datetime.now().year
#
# func = udf_nested_class\
"""
    )


@pytest.mark.skipif(not is_dateutil_available, reason="dateutil is required")
def test_add_import_package():
    def plus_one_month(x):
        return x + relativedelta(month=1)

    assert (
        generate_source_code(plus_one_month)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# from dateutil.relativedelta import relativedelta
# def plus_one_month(x):
#     return x + relativedelta(month=1)
#
# func = plus_one_month\
"""
    )


def test_negative_udfs():
    # classmethod is not supported yet
    class Foo:
        def bar1(self):
            pass

        @classmethod
        def bar2(cls):
            pass

    # The source code for whole class should be used
    # Check  https://snowflakecomputing.atlassian.net/browse/SNOW-644984
    assert (
        generate_source_code(Foo.bar1)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# def bar1(self):
#     pass
#
# func = bar1\
"""
    )
    assert generate_source_code(Foo.bar2) == ""
    assert generate_source_code(Foo().bar1) == ""
    assert generate_source_code(Foo().bar2) == ""


def test_remove_udf_annotation():
    # without parameters
    before_code = """\
@udf
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code)
        == """\
def test():
    pass\
"""
    )
    # with parameters
    before_code = """\
@udf(1=2,3=4,5=6)
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code)
        == """\
def test():
    pass\
"""
    )

    # multiple line parameters
    before_code = """\
@udf(
1=2
3=4,
a=b,
)
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code)
        == """\
def test():
    pass\
"""
    )

    # multiple annotation
    before_code = """\
@decorator1(1=2)
@udf(
1=2
3=4,
a=b,
)
@decorator2
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code)
        == """\
@decorator1(1=2)
@decorator2
def test():
    pass\
"""
    )
    # test a user-provided decorator starting from @udf but it's not @udf
    before_code = """\
@udff
def test():
    pass\
"""
    assert remove_function_udf_annotation(before_code) == before_code

    before_code = """\
@udf((1=2))
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code)
        == """\
def test():
    pass\
"""
    )

    with pytest.raises(TypeError):
        remove_function_udf_annotation(
            """\
@udf(1=2)
@udf()
@udf
def test():
    pass\
"""
        )


def test_lambda_code_extraction():
    register_code = "session.udf.register(lambda x, y: x + y)"
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = "session.udf.register(lambda x, y: x + y, 'a', 'b', 'c', d=1, e=2)"
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
    lambda x, y: x + y)"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
    lambda x, y: x + y, ...
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
lambda x, y: x + y, ...
# some comments
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
lambda x, y:\
 x + y, ...
# some comments
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
        lambda x, y: x + y, ...
        # some comments
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    with pytest.raises(TypeError, match="lambda function can not be extracted"):
        get_lambda_code_text("def f(): pass")


def test_import_module():
    from datetime import datetime

    from tests.unit.mock_module import Child, Parent, module_method, module_var

    def udf_import_class(a, b):
        return Parent().bar() + Child().bar() + datetime.now().year

    assert (
        generate_source_code(udf_import_class)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# from datetime import datetime
# from tests.unit.mock_module import Child, Parent
# def udf_import_class(a, b):
#     return Parent().bar() + Child().bar() + datetime.now().year
#
# func = udf_import_class\
"""
    )

    def udf_import_method(a, b, c):
        return module_method(a, b, c)

    assert (
        generate_source_code(udf_import_method)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# from tests.unit.mock_module import module_method
# def udf_import_method(a, b, c):
#     return module_method(a, b, c)
#
# func = udf_import_method\
"""
    )

    def udf_import_all(a, b, c):
        return Parent().bar() + Child().bar() + module_method(a, b, c) + module_var

    assert (
        generate_source_code(udf_import_all)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# from tests.unit.mock_module import Child, Parent, module_method
# module_var  # variable of type <class 'int'>
# def udf_import_all(a, b, c):
#     return Parent().bar() + Child().bar() + module_method(a, b, c) + module_var
#
# func = udf_import_all\
"""
    )


def test_get_func_references():
    import datetime
    from datetime import datetime as dt

    nonlocalvar = 123
    nonlocalvar_2 = "abc"

    class Cls:
        pass

    class Cls2:
        pass

    def another_func():
        nonlocalvar_2
        Cls2

    def func():
        nonlocalvar
        func
        dt
        Cls
        another_func
        datetime

    ref_objects = {}
    get_func_references(func, ref_objects)

    assert set(ref_objects.keys()) == {
        "nonlocalvar",
        "Cls",
        "dt",
        "func",
        "another_func",
        "nonlocalvar_2",
        "Cls2",
        "datetime",
    }

    assert (
        generate_source_code(func)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import datetime
# from datetime import datetime as dt
# nonlocalvar_2  # variable of type <class 'str'>
# nonlocalvar  # variable of type <class 'int'>
# class Cls2:
#     pass
# class Cls:
#     pass
# def another_func():
#     nonlocalvar_2
#     Cls2
# def func():
#     nonlocalvar
#     func
#     dt
#     Cls
#     another_func
#     datetime
#
# func = func\
"""
    )


@pytest.mark.xfail(reason="SNOW-684509", strict=True)
def test_get_class_references():

    from tests.unit.mock_module import Parent

    class AnotherChild(Parent):
        pass

    def f():
        AnotherChild

    ref_objects = {}
    get_class_references(AnotherChild, f, ref_objects, [])


@pytest.mark.skipif(not is_pandas_available, reason="requires pandas")
def test_import_multilevel_and_alias_modules():
    # check https://snowflakecomputing.atlassian.net/browse/SNOW-651634 for multi-level imports improvement
    import io
    import random as rd
    from datetime import date as d

    import pandas.io
    import pandas.io.api as pandas_api
    import pandas.io.sql
    from pandas.io.sql import read_sql

    def func():
        pandas.io
        io
        rd
        d
        read_sql
        pandas.io.sql.to_sql
        pandas_api

    ref_objects = {}
    get_func_references(func, ref_objects)
    assert set(ref_objects.keys()) == {
        "pandas",
        "io",
        "rd",
        "d",
        "read_sql",
        "pandas_api",
    }
    imports = extract_submodule_imports(
        func,
        [
            ref_objects["pandas"],
            ref_objects["io"],
            ref_objects["rd"],
            ref_objects["d"],
            ref_objects["read_sql"],
            ref_objects["pandas_api"],
        ],
    )
    assert imports == {("pandas.io", ""), ("pandas.io.sql", "")}

    assert (
        generate_source_code(func)
        == """\
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import io
# import pandas
# import pandas.io
# import pandas.io.api as pandas_api
# import pandas.io.sql
# import random as rd
# from datetime import date as d
# from pandas.io.sql import read_sql
# def func():
#     pandas.io
#     io
#     rd
#     d
#     read_sql
#     pandas.io.sql.to_sql
#     pandas_api
#
# func = func\
"""
    )


def test_variable_serialization():
    nonlocalvar = "abc"

    def add(x, y):
        return x + y + nonlocalvar

    assert (
        generate_source_code(add, code_as_comment=False)
        == """\
from __future__ import annotations
import pickle

nonlocalvar = pickle.loads(bytes.fromhex('80049507000000000000008c03616263942e'))  # nonlocalvar is of type <class 'str'> and serialized by snowpark-python
def add(x, y):
    return x + y + nonlocalvar
func = add\
"""
    )
