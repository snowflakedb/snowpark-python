#
# Copyright (c) 2012-2022 Snowflake Computing Inc. All rights reserved.
#

import math

import pytest

from snowflake.snowpark._internal.code_generation import (
    generate_source_code,
    get_lambda_code_text,
    remove_function_udf_annotation,
)

try:
    from dateutil.relativedelta import relativedelta

    is_dateutil_available = True
except ImportError:
    is_dateutil_available = False


def test_basic_udf():
    def add(x, y):
        return x + y

    assert (
        generate_source_code(add)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# def add(x, y):
#     return x + y
#
# func = add\
"""
    )
    lambda_func = lambda x, y: x * y  # noqa: E731
    assert (
        generate_source_code(lambda_func)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# func = lambda x, y: x * y\
"""
    )


def test_non_local_or_global_vars():
    var = 123

    def udf():
        return var + 1

    assert (
        generate_source_code(udf)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# var  # variable of type <class 'int'>
# def udf():
#     return var + 1
#
# func = udf\
"""
    )


def test_recursive_udf():
    def factorial(n):
        return 1 if n == 1 or n == 0 else n * factorial(n - 1)

    assert (
        generate_source_code(factorial)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# def factorial(n):
#     return 1 if n == 1 or n == 0 else n * factorial(n - 1)
#
# func = factorial\
"""
    )


def test_nested_udf():
    def outer_func():
        def inner_func():
            return "snow"

        return f"{inner_func()}-{inner_func()}"

    def square(x):
        return x**2

    def cube(x):
        return square(x) * x

    assert (
        generate_source_code(outer_func)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# def outer_func():
#     def inner_func():
#         return "snow"
#
#     return f"{inner_func()}-{inner_func()}"
#
# func = outer_func\
"""
    )

    assert (
        generate_source_code(cube)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# def square(x):
#     return x**2
# def cube(x):
#     return square(x) * x
#
# func = cube\
"""
    )


def test_python_built_in():
    def my_sqrt(x):
        return math.sqrt(x)

    assert (
        generate_source_code(my_sqrt)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# import math
# def my_sqrt(x):
#     return math.sqrt(x)
#
# func = my_sqrt\
"""
    )

    assert (
        generate_source_code(abs)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# func = abs\
"""
    )

    assert (
        generate_source_code(math.sqrt)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# import math
# func = math.sqrt\
"""
    )


def test_class_used_in_udf():
    import datetime

    class Foo:
        def bar(self):
            return 1

    class Parent(Foo):
        class Child:
            def bar(self):
                return 1

    def udf(a, b):
        return Foo().bar() + datetime.datetime.now().year

    def udf_nested_class(a, b):
        return Parent().Child().bar() + datetime.datetime.now().year

    assert (
        generate_source_code(udf)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# import datetime
# class Foo:
#     def bar(self):
#         return 1
# def udf(a, b):
#     return Foo().bar() + datetime.datetime.now().year
#
# func = udf\
"""
    )

    assert (
        generate_source_code(udf_nested_class)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# import datetime
# class Foo:
#     def bar(self):
#         return 1
# class Parent(Foo):
#     class Child:
#         def bar(self):
#             return 1
# def udf_nested_class(a, b):
#     return Parent().Child().bar() + datetime.datetime.now().year
#
# func = udf_nested_class\
"""
    )


@pytest.mark.skipif(not is_dateutil_available, reason="dateutil is required")
def test_add_import_package():
    def plus_one_month(x):
        return x + relativedelta(month=1)

    assert (
        generate_source_code(plus_one_month)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# from dateutil.relativedelta import relativedelta
# def plus_one_month(x):
#     return x + relativedelta(month=1)
#
# func = plus_one_month\
"""
    )


def test_negative_udfs():
    # classmethod is not supported yet
    class Foo:
        def bar1(self):
            pass

        @classmethod
        def bar2(cls):
            pass

    # The source code for whole class should be used
    # Check  https://snowflakecomputing.atlassian.net/browse/SNOW-644984
    assert (
        generate_source_code(Foo.bar1)
        == """\
# The following comment contains the UDF source code generated by snowpark-python for explanatory purposes.
# def bar1(self):
#     pass
#
# func = bar1\
"""
    )
    assert generate_source_code(Foo.bar2) == ""
    assert generate_source_code(Foo().bar1) == ""
    assert generate_source_code(Foo().bar2) == ""


def test_remove_udf_annotation():
    # without parameters
    before_code = """\
@udf
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code, code_as_comment=False)
        == """\
def test():
    pass\
"""
    )
    # with parameters
    before_code = """\
@udf(1=2,3=4,5=6)
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code, code_as_comment=False)
        == """\
def test():
    pass\
"""
    )

    # multiple line parameters
    before_code = """\
@udf(
1=2
3=4,
a=b,
)
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code, code_as_comment=False)
        == """\
def test():
    pass\
"""
    )

    # multiple annotation
    before_code = """\
@decorator1(1=2)
@udf(
1=2
3=4,
a=b,
)
@decorator2
def test():
    pass\
"""
    assert (
        remove_function_udf_annotation(before_code, code_as_comment=False)
        == """\
@decorator1(1=2)
@decorator2
def test():
    pass\
"""
    )


def test_lambda_code_extraction():
    register_code = "session.udf.register(lambda x, y: x + y)"
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = "session.udf.register(lambda x, y: x + y, 'a', 'b', 'c', d=1, e=2)"
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
lambda x, y: x + y, ...
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
lambda x, y: x + y, ...
# some comments
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"

    register_code = """\
session.udf.register(
lambda x, y:\
 x + y, ...
# some comments
)\
"""
    assert get_lambda_code_text(register_code) == "lambda x, y: x + y"
