## TEST CASE

from snowflake.snowpark.functions import col, udf

from snowflake.snowpark.types import IntegerType, FloatType

add_one = udf(lambda x: x + 1, return_type=IntegerType(), input_types=[IntegerType()])

df = session.create_dataframe([1, 2, 3], schema=["a"])

df.select(add_one(col("a")).as_("ans")).collect()

# call_udf should be encoded as builtin applexpr. It only works for named (& permanently) registered udfs.

add_two = udf(lambda x: x + 2, return_type=IntegerType(), input_types=[IntegerType()], name="add_two", replace=True)

df.select(call_udf("add_two", col("A")).as_("a_Ans")).collect()

param_udf = udf(lambda x, y: str(y + x**2), return_type=VariantType(), input_types=[IntegerType(), FloatType()],
                name="param_udf", is_permanent=True, stage_location="@", imports=["numpy"], packages=["bla"],
                replace=True, if_not_exists=False, parallel=8, max_batch_size=2, source_code_display=False,
                strict=True, secure=True, external_access_integrations=["s3"], secrets={'a':'b', 'c':'d'},
                immutable=True, comment="some udf", force_inline_code=True)

# Another test udf because if_not_exists and replace need to be xor.
param_udf2 = udf(lambda x, y: str(y + x**2), return_type=VariantType(), input_types=[IntegerType(), FloatType()],
                 name="param_udf2", is_permanent=True, stage_location="@", imports=["numpy"], packages=["bla"],
                 replace=False, if_not_exists=True, parallel=8, max_batch_size=2, source_code_display=False,
                 strict=True, secure=True, external_access_integrations=["s3"], secrets={'a':'b', 'c':'d'},
                 immutable=True, comment="some udf", force_inline_code=True)

df.select(param_udf(col("A"), col("A")))

## EXPECTED UNPARSER OUTPUT

add_one = udf(<lambda>, return_type=IntegerType(), input_types=[IntegerType()])

df = session.create_dataframe([1, 2, 3], schema=["a"])

df.select(add_one(col("a")).as_("ans")).collect()

add_two = udf(<lambda [1]>, return_type=IntegerType(), input_types=[IntegerType()], name="add_two", replace=True)

df.select(call_udf("add_two", col("A")).as_("a_Ans")).collect()

param_udf = udf(<lambda [2]>, return_type=VariantType(), input_types=[IntegerType()]FloatType()], name="param_udf", is_permanent=True, stage_location="@", imports=["numpy"], packages=["bla"], replace=True, parallel=8, max_batch_size=2, source_code_display=False, strict=True, secure=True, external_access_integrations=["s3"], secrets={"a": "b"}{"c": "d"}, immutable=True, comment="some udf")

param_udf2 = udf(<lambda [3]>, return_type=VariantType(), input_types=[IntegerType()]FloatType()], name="param_udf2", is_permanent=True, stage_location="@", imports=["numpy"], packages=["bla"], if_not_exists=True, parallel=8, max_batch_size=2, source_code_display=False, strict=True, secure=True, external_access_integrations=["s3"], secrets={"a": "b"}{"c": "d"}, immutable=True, comment="some udf")

res5 = df.select(param_udf(col("A"), col("A")))

## EXPECTED ENCODED AST

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
