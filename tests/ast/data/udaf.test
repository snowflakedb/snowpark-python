## TEST CASE

from snowflake.snowpark.functions import col, udaf

from snowflake.snowpark.types import IntegerType
class PythonSumUDAF:
    def __init__(self) -> None:
        self._sum = 0

    @property
    def aggregate_state(self):
        return self._sum

    def accumulate(self, input_value):
        self._sum += input_value

    def merge(self, other_sum):
        self._sum += other_sum

    def finish(self):
        return self._sum

sum_udaf = udaf(
    PythonSumUDAF,
    name="sum_int",
    replace=True,
    return_type=IntegerType(),
    input_types=[IntegerType()],
)

df = session.create_dataframe([[1, 3], [1, 4], [2, 5], [2, 6]]).to_df("a", "b")

df.agg(sum_udaf("a")).collect()


import heapq
from dataclasses import dataclass
import itertools
from typing import List

@dataclass
class AggState:
    minheap: List[int]
    k: int

class PythonTopK:
    def __init__(self):
        self._agg_state = AggState([], 0)

    @property
    def aggregate_state(self):
        return self._agg_state

    @staticmethod
    def get_top_k_items(minheap, k):
      # Return k smallest elements if there are more than k elements on the min heap.
      if (len(minheap) > k):
        return [heapq.heappop(minheap) for i in range(k)]
      return minheap

    def accumulate(self, input, k):
        self._agg_state.k = k

        # Store the input as negative value, as heapq is a min heap.
        heapq.heappush(self._agg_state.minheap, -input)

        # Store only top k items on the min heap.
        self._agg_state.minheap = self.get_top_k_items(self._agg_state.minheap, k)

    def merge(self, other_agg_state):
        k = self._agg_state.k if self._agg_state.k > 0 else other_agg_state.k

        # Merge two min heaps by popping off elements from one and pushing them onto another.
        while(len(other_agg_state.minheap) > 0):
            heapq.heappush(self._agg_state.minheap, heapq.heappop(other_agg_state.minheap))

        # Store only k elements on the min heap.
        self._agg_state.minheap = self.get_top_k_items(self._agg_state.minheap, k)

    def finish(self):
        return [-x for x in self._agg_state.minheap]

u2 = udaf(PythonTopK, return_type=IntegerType(), input_types=[IntegerType()], name="top_k", is_permanent=True,
          stage_location="@", imports=["numpy"], packages=["numpy"], replace=True, if_not_exists=False, parallel=8,
          statement_params={'a':'b'}, immutable=True, external_access_integrations=['s3'], secrets={'a':'c'},
          comment='test udaf', force_inline_code=True)

df.agg(u2("a"))

## EXPECTED UNPARSER OUTPUT

sum_udaf = udaf(PythonSumUDAF, return_type=IntegerType(), input_types=[IntegerType()], name="sum_int", replace=True, source_code_display=True)

df = session.create_dataframe([[1, 3], [1, 4], [2, 5], [2, 6]])

df = df.to_df("a", "b")

df.agg(sum_udaf("a")).collect()

u2 = udaf(PythonTopK, return_type=IntegerType(), input_types=[IntegerType()], name="top_k", is_permanent=True, stage_location="@", imports=["numpy"], packages=["numpy"], replace=True, parallel=8, statement_params=, statement_params={"a": "b"}, external_access_integrations=["s3"], secrets={"a": "c"}, immutable=True, comment="test udaf", source_code_display=True)

res3 = df.agg(u2("a"))

## EXPECTED ENCODED AST

CqsBCqgBCpMB4gyPARoPEg1QeXRob25TdW1VREFGOgQKAmABSj4KE3NvdXJjZV9jb2RlX2Rpc3BsYXkSJ8IBJAogCAkQdBoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSATKG4QAVILCgkKB3N1bV9pbnRgBGgBcgJgAYIBIAgJEHQaFlNSQ19QT1NJVElPTl9URVNUX01PREUgEyhuEgoKCHN1bV91ZGFmGAEiAggBCqIECp8ECpAEggaMBArnAwrkAwp30gJ0CiAIRxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odhInwgIkCiAIRxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odhABEifCAiQKIAhHEHYaFlNSQ19QT1NJVElPTl9URVNUX01PREUgDSh2EAMKd9ICdAogCEcQdhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSANKHYSJ8ICJAogCEcQdhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSANKHYQARInwgIkCiAIRxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odhAECnfSAnQKIAhHEHYaFlNSQ19QT1NJVElPTl9URVNUX01PREUgDSh2EifCAiQKIAhHEHYaFlNSQ19QT1NJVElPTl9URVNUX01PREUgDSh2EAISJ8ICJAogCEcQdhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSANKHYQBQp30gJ0CiAIRxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odhInwgIkCiAIRxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odhACEifCAiQKIAhHEHYaFlNSQ19QT1NJVElPTl9URVNUX01PREUgDSh2EAYaIAhHEHYaFlNSQ19QT1NJVElPTl9URVNUX01PREUgDSh2EgQKAmRmGAIiAggCCkYKRAo20gkzCgFhCgFiEgeCAgQKAggCGiAIVxB2GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0odiABEgQKAmRmGAMiAggDCpoBCpcBCowBigaIAQoHggIECgIIAxJbCleKAVQKBkoECgIIARoougwlCiAIHBB4GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA8oeBIBYSIgCBwQeBoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSAPKHgQARogCB0QeBoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSAIKHgSABgEIgIIBAo5CjcKLdoGKggBEAEaAggEMiAIJxB4GhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIAgoeBIAGAUiAggFCggSBggGEgIIBRABGhESDwoNCgVmaW5hbBADGAsgCSIEEAEYFQ==
CuQBCuEBCtIB4gzOAQoLCgl0ZXN0IHVkYWYSAnMzGg4IARIKUHl0aG9uVG9wSygBMgkKBwoFbnVtcHk6BAoCYAFAAUpAChNzb3VyY2VfY29kZV9kaXNwbGF5EinCASYKIgg+EK0BGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIA0oqgEQAVIJCgcKBXRvcF9rWgVudW1weWAIaAFyAmABegYKAWESAWOCASIIPhCtARoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSANKKoBigEDCgFAkgEGCgFhEgFiEgQKAnUyGAciAggHCqABCp0BCpIBigaOAQoHggIECgIIAxJfCluKAVgKBkoECgIIBxoqugwnCiIIFhCvARoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSAPKK8BEgFhIiIIFhCvARoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSAPKK8BEAEaIggXEK8BGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFIAgorwESABgIIgIICBABGhESDwoNCgVmaW5hbBADGAsgCSIEEAEYFQ==
