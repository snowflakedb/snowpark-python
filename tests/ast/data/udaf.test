## TEST CASE

from snowflake.snowpark.functions import col, udaf

from snowflake.snowpark.types import IntegerType
class PythonSumUDAF:
    def __init__(self) -> None:
        self._sum = 0

    @property
    def aggregate_state(self):
        return self._sum

    def accumulate(self, input_value):
        self._sum += input_value

    def merge(self, other_sum):
        self._sum += other_sum

    def finish(self):
        return self._sum

sum_udaf = udaf(
    PythonSumUDAF,
    name="sum_int",
    replace=True,
    return_type=IntegerType(),
    input_types=[IntegerType()],
)

df = session.create_dataframe([[1, 3], [1, 4], [2, 5], [2, 6]]).to_df("a", "b")

df.agg(sum_udaf("a")).collect()


import heapq
from dataclasses import dataclass
import itertools
from typing import List

@dataclass
class AggState:
    minheap: List[int]
    k: int

class PythonTopK:
    def __init__(self):
        self._agg_state = AggState([], 0)

    @property
    def aggregate_state(self):
        return self._agg_state

    @staticmethod
    def get_top_k_items(minheap, k):
      # Return k smallest elements if there are more than k elements on the min heap.
      if (len(minheap) > k):
        return [heapq.heappop(minheap) for i in range(k)]
      return minheap

    def accumulate(self, input, k):
        self._agg_state.k = k

        # Store the input as negative value, as heapq is a min heap.
        heapq.heappush(self._agg_state.minheap, -input)

        # Store only top k items on the min heap.
        self._agg_state.minheap = self.get_top_k_items(self._agg_state.minheap, k)

    def merge(self, other_agg_state):
        k = self._agg_state.k if self._agg_state.k > 0 else other_agg_state.k

        # Merge two min heaps by popping off elements from one and pushing them onto another.
        while(len(other_agg_state.minheap) > 0):
            heapq.heappush(self._agg_state.minheap, heapq.heappop(other_agg_state.minheap))

        # Store only k elements on the min heap.
        self._agg_state.minheap = self.get_top_k_items(self._agg_state.minheap, k)

    def finish(self):
        return [-x for x in self._agg_state.minheap]

u2 = udaf(PythonTopK, return_type=IntegerType(), input_types=[IntegerType()], name="top_k", is_permanent=True,
          stage_location="@", imports=["numpy"], packages=["numpy"], replace=True, if_not_exists=False, parallel=8,
          statement_params={'a':'b'}, immutable=True, external_access_integrations=['s3'], secrets={'a':'c'},
          comment='test udaf', force_inline_code=True)

df.agg(u2("a"))

## EXPECTED UNPARSER OUTPUT

df = session.create_dataframe([[1, 3], [1, 4], [2, 5], [2, 6]])

df = df.to_df("a", "b")

df.agg(udaf(PythonSumUDAF, return_type=IntegerType(), input_types=[IntegerType()], name="sum_int", replace=True, source_code_display=True)("a")).collect()

res5 = df.agg(udaf(PythonTopK, return_type=IntegerType(), input_types=[IntegerType()], name="top_k", is_permanent=True, stage_location="@", imports=["numpy"], packages=["numpy"], replace=True, parallel=8, statement_params=, statement_params={"a": "b"}, external_access_integrations=["s3"], secrets={"a": "c"}, immutable=True, comment="test udaf", source_code_display=True)("a"))

## EXPECTED ENCODED AST

CpUBCpIBCocBogyDARoPEg1QeXRob25TdW1VREFGOgQKAmABSjgKE3NvdXJjZV9jb2RlX2Rpc3BsYXkSIbIBHgoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKG4QAVILCgkKB3N1bV9pbnRgBGgBcgJgAYIBGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERShuEgAYASICCAEK1AMK0QMKwgPSBb4DCp8DCpwDCmWiAmIKGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2EiGSAh4KGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2EAESIZICHgoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKHYQAwplogJiChoaFlNSQ19QT1NJVElPTl9URVNUX01PREUodhIhkgIeChoaFlNSQ19QT1NJVElPTl9URVNUX01PREUodhABEiGSAh4KGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2EAQKZaICYgoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKHYSIZICHgoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKHYQAhIhkgIeChoaFlNSQ19QT1NJVElPTl9URVNUX01PREUodhAFCmWiAmIKGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2EiGSAh4KGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2EAISIZICHgoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKHYQBhoaGhZTUkNfUE9TSVRJT05fVEVTVF9NT0RFKHYSBAoCZGYYAiICCAIKQAo+CjCyCS0KAWEKAWISB4oCBAoCCAIaGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh2IAESBAoCZGYYAyICCAMKhQEKggEKeNoFdQoHigIECgIIAxJOCkp6SAoGGgQKAggBGiLyCx8KGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh4EgFhIhoaFlNSQ19QT1NJVElPTl9URVNUX01PREUoeBABGhoaFlNSQ19QT1NJVElPTl9URVNUX01PREUoeBIAGAQiAggECjMKMQonqgYkCAEQARoCCAQyGhoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSh4EgAYBSICCAUKCBIGCAYSAggFEAEaERIPCg0KBWZpbmFsEAMYCCATIgQQARgV
CtIBCs8BCsQBogzAAQoLCgl0ZXN0IHVkYWYSAnMzGg4IARIKUHl0aG9uVG9wSygBMgkKBwoFbnVtcHk6BAoCYAFAAUo5ChNzb3VyY2VfY29kZV9kaXNwbGF5EiKyAR8KGxoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSiqARABUgkKBwoFdG9wX2taBW51bXB5YAhoAXICYAF6BgoBYRIBY4IBGxoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSiqAYoBAwoBQJIBBgoBYRIBYhIAGAciAggHCogBCoUBCnvaBXgKB4oCBAoCCAMSUApMekoKBhoECgIIBxoj8gsgChsaFlNSQ19QT1NJVElPTl9URVNUX01PREUorwESAWEiGxoWU1JDX1BPU0lUSU9OX1RFU1RfTU9ERSivARABGhsaFlNSQ19QT1NJVElPTl9URVNUX01PREUorwESABgIIgIICBABGhESDwoNCgVmaW5hbBADGAggEyIEEAEYFQ==
